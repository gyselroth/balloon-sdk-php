<?php
/**
 * CoreV2Api
 * PHP version 5
 *
 * @category Class
 * @package  Balloon\Sdk
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * balloon API
 *
 * balloon API
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Balloon\Sdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Balloon\Sdk\ApiException;
use Balloon\Sdk\Configuration;
use Balloon\Sdk\HeaderSelector;
use Balloon\Sdk\ObjectSerializer;

/**
 * CoreV2Api Class Doc Comment
 *
 * @category Class
 * @package  Balloon\Sdk
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CoreV2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addGroup
     *
     * Add new group
     *
     * @param  \Balloon\Sdk\Model\Group $data data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Group
     */
    public function addGroup($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';

        try {
            try {
                $response = $this->addGroupRequest($data);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation addGroupWithHttpInfo
     *
     * Add new group
     *
     * @param  \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function addGroupRequest($data = null)
    {
        $request = $this->addGroupPrepareRequest($data);
        return $this->client->send($request);
    }

    /**
     * Operation addGroupAsync
     *
     * Add new group
     *
     * @param  \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addGroupAsync($data = null)
    {
        return $this->addGroupAsyncWithHttpInfo($data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addGroupAsyncWithHttpInfo
     *
     * Add new group
     *
     * @param  \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addGroupAsyncWithHttpInfo($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->addGroupRequest($data);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addGroup'
     *
     * @param  \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addGroupPrepareRequest($data = null)
    {

        $resourcePath = '/api/v2/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addUser
     *
     * Add new user
     *
     * @param  \Balloon\Sdk\Model\User $data data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\User
     */
    public function addUser($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';

        try {
            try {
                $response = $this->addUserRequest($data);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation addUserWithHttpInfo
     *
     * Add new user
     *
     * @param  \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function addUserRequest($data = null)
    {
        $request = $this->addUserPrepareRequest($data);
        return $this->client->send($request);
    }

    /**
     * Operation addUserAsync
     *
     * Add new user
     *
     * @param  \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUserAsync($data = null)
    {
        return $this->addUserAsyncWithHttpInfo($data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addUserAsyncWithHttpInfo
     *
     * Add new user
     *
     * @param  \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUserAsyncWithHttpInfo($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->addUserRequest($data);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addUser'
     *
     * @param  \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addUserPrepareRequest($data = null)
    {

        $resourcePath = '/api/v2/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloneNode
     *
     * Clone existing node
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Node
     */
    public function cloneNode($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';

        try {
            try {
                $response = $this->cloneNodeRequest($node, $destid, $conflict);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation cloneNodeWithHttpInfo
     *
     * Clone existing node
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloneNodeRequest($node, $destid = null, $conflict = '0')
    {
        $request = $this->cloneNodePrepareRequest($node, $destid, $conflict);
        return $this->client->send($request);
    }

    /**
     * Operation cloneNodeAsync
     *
     * Clone existing node
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneNodeAsync($node, $destid = null, $conflict = '0')
    {
        return $this->cloneNodeAsyncWithHttpInfo($node, $destid, $conflict)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloneNodeAsyncWithHttpInfo
     *
     * Clone existing node
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneNodeAsyncWithHttpInfo($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->cloneNodeRequest($node, $destid, $conflict);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloneNode'
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cloneNodePrepareRequest($node, $destid = null, $conflict = '0')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling cloneNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/clone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($destid !== null) {
            $queryParams['destid'] = ObjectSerializer::toQueryValue($destid);
        }
        // query params
        if ($conflict !== null) {
            $queryParams['conflict'] = ObjectSerializer::toQueryValue($conflict);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCollection
     *
     * Create a new collection
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body body (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Collection
     */
    public function createCollection($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';

        try {
            try {
                $response = $this->createCollectionRequest($collection, $body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation createCollectionWithHttpInfo
     *
     * Create a new collection
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Collection, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCollectionRequest($collection, $body)
    {
        $request = $this->createCollectionPrepareRequest($collection, $body);
        return $this->client->send($request);
    }

    /**
     * Operation createCollectionAsync
     *
     * Create a new collection
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectionAsync($collection, $body)
    {
        return $this->createCollectionAsyncWithHttpInfo($collection, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCollectionAsyncWithHttpInfo
     *
     * Create a new collection
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectionAsyncWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->createCollectionRequest($collection, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCollection'
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCollectionPrepareRequest($collection, $body)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling createCollection'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createCollection'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{' . 'collection' . '}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRootCollection
     *
     * Create a new collection in root
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body body (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Collection
     */
    public function createRootCollection($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';

        try {
            try {
                $response = $this->createRootCollectionRequest($collection, $body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation createRootCollectionWithHttpInfo
     *
     * Create a new collection in root
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Collection, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRootCollectionRequest($collection, $body)
    {
        $request = $this->createRootCollectionPrepareRequest($collection, $body);
        return $this->client->send($request);
    }

    /**
     * Operation createRootCollectionAsync
     *
     * Create a new collection in root
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRootCollectionAsync($collection, $body)
    {
        return $this->createRootCollectionAsyncWithHttpInfo($collection, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRootCollectionAsyncWithHttpInfo
     *
     * Create a new collection in root
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRootCollectionAsyncWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->createRootCollectionRequest($collection, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRootCollection'
     *
     * @param  string $collection Parent collection (required)
     * @param  \Balloon\Sdk\Model\Collection $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRootCollectionPrepareRequest($collection, $body)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling createRootCollection'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createRootCollection'
            );
        }

        $resourcePath = '/api/v2/collections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{' . 'collection' . '}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGroup
     *
     * Delete group
     *
     * @param  string $group Resource identifier (required)
     * @param  bool $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteGroup($group, $force = null)
    {
        $returnType = '';

        try {
            try {
                $response = $this->deleteGroupRequest($group, $force);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return null;
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }


    /**
     * Operation deleteGroupWithHttpInfo
     *
     * Delete group
     *
     * @param  string $group Resource identifier (required)
     * @param  bool $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGroupRequest($group, $force = null)
    {
        $request = $this->deleteGroupPrepareRequest($group, $force);
        return $this->client->send($request);
    }

    /**
     * Operation deleteGroupAsync
     *
     * Delete group
     *
     * @param  string $group Resource identifier (required)
     * @param  bool $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGroupAsync($group, $force = null)
    {
        return $this->deleteGroupAsyncWithHttpInfo($group, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGroupAsyncWithHttpInfo
     *
     * Delete group
     *
     * @param  string $group Resource identifier (required)
     * @param  bool $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGroupAsyncWithHttpInfo($group, $force = null)
    {
        $returnType = '';
        $request = $this->deleteGroupRequest($group, $force);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGroup'
     *
     * @param  string $group Resource identifier (required)
     * @param  bool $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteGroupPrepareRequest($group, $force = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling deleteGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNode
     *
     * Delete node
     *
     * @param  string $node Node identifier (required)
     * @param  bool $force Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param  bool $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param  float $at Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNode($node, $force = null, $ignore_flag = null, $at = null)
    {
        $returnType = '';

        try {
            try {
                $response = $this->deleteNodeRequest($node, $force, $ignore_flag, $at);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return null;
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }


    /**
     * Operation deleteNodeWithHttpInfo
     *
     * Delete node
     *
     * @param  string $node Node identifier (required)
     * @param  bool $force Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param  bool $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param  float $at Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNodeRequest($node, $force = null, $ignore_flag = null, $at = null)
    {
        $request = $this->deleteNodePrepareRequest($node, $force, $ignore_flag, $at);
        return $this->client->send($request);
    }

    /**
     * Operation deleteNodeAsync
     *
     * Delete node
     *
     * @param  string $node Node identifier (required)
     * @param  bool $force Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param  bool $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param  float $at Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNodeAsync($node, $force = null, $ignore_flag = null, $at = null)
    {
        return $this->deleteNodeAsyncWithHttpInfo($node, $force, $ignore_flag, $at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNodeAsyncWithHttpInfo
     *
     * Delete node
     *
     * @param  string $node Node identifier (required)
     * @param  bool $force Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param  bool $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param  float $at Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNodeAsyncWithHttpInfo($node, $force = null, $ignore_flag = null, $at = null)
    {
        $returnType = '';
        $request = $this->deleteNodeRequest($node, $force, $ignore_flag, $at);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNode'
     *
     * @param  string $node Node identifier (required)
     * @param  bool $force Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param  bool $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param  float $at Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNodePrepareRequest($node, $force = null, $ignore_flag = null, $at = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling deleteNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force);
        }
        // query params
        if ($ignore_flag !== null) {
            $queryParams['ignore_flag'] = ObjectSerializer::toQueryValue($ignore_flag);
        }
        // query params
        if ($at !== null) {
            $queryParams['at'] = ObjectSerializer::toQueryValue($at);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteShare
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteShare($collection)
    {
        $returnType = '';

        try {
            try {
                $response = $this->deleteShareRequest($collection);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return null;
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }


    /**
     * Operation deleteShareWithHttpInfo
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteShareRequest($collection)
    {
        $request = $this->deleteSharePrepareRequest($collection);
        return $this->client->send($request);
    }

    /**
     * Operation deleteShareAsync
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShareAsync($collection)
    {
        return $this->deleteShareAsyncWithHttpInfo($collection)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteShareAsyncWithHttpInfo
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShareAsyncWithHttpInfo($collection)
    {
        $returnType = '';
        $request = $this->deleteShareRequest($collection);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteShare'
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSharePrepareRequest($collection)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling deleteShare'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{' . 'collection' . '}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUser
     *
     * Delete user
     *
     * @param  string $user Resource identifier (required)
     * @param  bool $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteUser($user, $force = null)
    {
        $returnType = '';

        try {
            try {
                $response = $this->deleteUserRequest($user, $force);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return null;
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }


    /**
     * Operation deleteUserWithHttpInfo
     *
     * Delete user
     *
     * @param  string $user Resource identifier (required)
     * @param  bool $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserRequest($user, $force = null)
    {
        $request = $this->deleteUserPrepareRequest($user, $force);
        return $this->client->send($request);
    }

    /**
     * Operation deleteUserAsync
     *
     * Delete user
     *
     * @param  string $user Resource identifier (required)
     * @param  bool $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsync($user, $force = null)
    {
        return $this->deleteUserAsyncWithHttpInfo($user, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserAsyncWithHttpInfo
     *
     * Delete user
     *
     * @param  string $user Resource identifier (required)
     * @param  bool $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsyncWithHttpInfo($user, $force = null)
    {
        $returnType = '';
        $request = $this->deleteUserRequest($user, $force);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUser'
     *
     * @param  string $user Resource identifier (required)
     * @param  bool $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteUserPrepareRequest($user, $force = null)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling deleteUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force);
        }

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApi
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\ApiRoot
     */
    public function getApi()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';

        try {
            try {
                $response = $this->getApiRequest();
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\ApiRoot',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getApiWithHttpInfo
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\ApiRoot, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiRequest()
    {
        $request = $this->getApiPrepareRequest();
        return $this->client->send($request);
    }

    /**
     * Operation getApiAsync
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiAsync()
    {
        return $this->getApiAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiAsyncWithHttpInfo
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiAsyncWithHttpInfo()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';
        $request = $this->getApiRequest();

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApi'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiPrepareRequest()
    {

        $resourcePath = '/api';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChildren
     *
     * Get all children of a collection
     *
     * @param  string $collection Parent collection (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getChildren($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';

        try {
            try {
                $response = $this->getChildrenRequest($collection, $query, $attributes, $offset, $limit, $sort, $recursive);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getChildrenWithHttpInfo
     *
     * Get all children of a collection
     *
     * @param  string $collection Parent collection (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChildrenRequest($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $request = $this->getChildrenPrepareRequest($collection, $query, $attributes, $offset, $limit, $sort, $recursive);
        return $this->client->send($request);
    }

    /**
     * Operation getChildrenAsync
     *
     * Get all children of a collection
     *
     * @param  string $collection Parent collection (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAsync($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        return $this->getChildrenAsyncWithHttpInfo($collection, $query, $attributes, $offset, $limit, $sort, $recursive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChildrenAsyncWithHttpInfo
     *
     * Get all children of a collection
     *
     * @param  string $collection Parent collection (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAsyncWithHttpInfo($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getChildrenRequest($collection, $query, $attributes, $offset, $limit, $sort, $recursive);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChildren'
     *
     * @param  string $collection Parent collection (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChildrenPrepareRequest($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling getChildren'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($recursive !== null) {
            $queryParams['recursive'] = ObjectSerializer::toQueryValue($recursive);
        }

        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{' . 'collection' . '}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCollections
     *
     * Get all collections
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Collections
     */
    public function getCollections($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Collections';

        try {
            try {
                $response = $this->getCollectionsRequest($query, $attributes, $offset, $limit, $sort);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collections',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getCollectionsWithHttpInfo
     *
     * Get all collections
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Collections, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCollectionsRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $request = $this->getCollectionsPrepareRequest($query, $attributes, $offset, $limit, $sort);
        return $this->client->send($request);
    }

    /**
     * Operation getCollectionsAsync
     *
     * Get all collections
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectionsAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getCollectionsAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCollectionsAsyncWithHttpInfo
     *
     * Get all collections
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectionsAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Collections';
        $request = $this->getCollectionsRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCollections'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCollectionsPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {

        $resourcePath = '/api/v2/collections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContent
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param  string $node Node identifier (required)
     * @param  float $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param  string $encode Can be set to base64 to encode content as base64. (optional)
     * @param  bool $download Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getContent($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        $returnType = '\SplFileObject';

        try {
            try {
                $response = $this->getContentRequest($node, $byte_ranges, $encode, $download);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getContentWithHttpInfo
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param  string $node Node identifier (required)
     * @param  float $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param  string $encode Can be set to base64 to encode content as base64. (optional)
     * @param  bool $download Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContentRequest($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        $request = $this->getContentPrepareRequest($node, $byte_ranges, $encode, $download);
        return $this->client->send($request);
    }

    /**
     * Operation getContentAsync
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param  string $node Node identifier (required)
     * @param  float $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param  string $encode Can be set to base64 to encode content as base64. (optional)
     * @param  bool $download Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentAsync($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        return $this->getContentAsyncWithHttpInfo($node, $byte_ranges, $encode, $download)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContentAsyncWithHttpInfo
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param  string $node Node identifier (required)
     * @param  float $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param  string $encode Can be set to base64 to encode content as base64. (optional)
     * @param  bool $download Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentAsyncWithHttpInfo($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->getContentRequest($node, $byte_ranges, $encode, $download);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContent'
     *
     * @param  string $node Node identifier (required)
     * @param  float $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param  string $encode Can be set to base64 to encode content as base64. (optional)
     * @param  bool $download Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getContentPrepareRequest($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling getContent'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($encode !== null) {
            $queryParams['encode'] = ObjectSerializer::toQueryValue($encode);
        }
        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // header params
        if ($byte_ranges !== null) {
            $headerParams['Byte-Ranges'] = ObjectSerializer::toHeaderValue($byte_ranges);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['octet/stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['octet/stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentUser
     *
     * Get user object of the current authenticated user
     *
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\User
     */
    public function getCurrentUser($attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';

        try {
            try {
                $response = $this->getCurrentUserRequest($attributes);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getCurrentUserWithHttpInfo
     *
     * Get user object of the current authenticated user
     *
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentUserRequest($attributes = null)
    {
        $request = $this->getCurrentUserPrepareRequest($attributes);
        return $this->client->send($request);
    }

    /**
     * Operation getCurrentUserAsync
     *
     * Get user object of the current authenticated user
     *
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentUserAsync($attributes = null)
    {
        return $this->getCurrentUserAsyncWithHttpInfo($attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentUserAsyncWithHttpInfo
     *
     * Get user object of the current authenticated user
     *
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentUserAsyncWithHttpInfo($attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getCurrentUserRequest($attributes);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentUser'
     *
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrentUserPrepareRequest($attributes = null)
    {

        $resourcePath = '/api/v2/users/whoami';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeletedNodes
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getDeletedNodes($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';

        try {
            try {
                $response = $this->getDeletedNodesRequest($query, $attributes, $offset, $limit, $sort);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getDeletedNodesWithHttpInfo
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeletedNodesRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $request = $this->getDeletedNodesPrepareRequest($query, $attributes, $offset, $limit, $sort);
        return $this->client->send($request);
    }

    /**
     * Operation getDeletedNodesAsync
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeletedNodesAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getDeletedNodesAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeletedNodesAsyncWithHttpInfo
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeletedNodesAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getDeletedNodesRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeletedNodes'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeletedNodesPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {

        $resourcePath = '/api/v2/nodes/trash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDelta
     *
     * Delta stream with cursor support.
     *
     * @param  float $limit Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param  string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param  string $cursor Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Delta
     */
    public function getDelta($limit = null, $attributes = null, $cursor = null)
    {
        $returnType = '\Balloon\Sdk\Model\Delta';

        try {
            try {
                $response = $this->getDeltaRequest($limit, $attributes, $cursor);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Delta',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getDeltaWithHttpInfo
     *
     * Delta stream with cursor support.
     *
     * @param  float $limit Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param  string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param  string $cursor Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Delta, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeltaRequest($limit = null, $attributes = null, $cursor = null)
    {
        $request = $this->getDeltaPrepareRequest($limit, $attributes, $cursor);
        return $this->client->send($request);
    }

    /**
     * Operation getDeltaAsync
     *
     * Delta stream with cursor support.
     *
     * @param  float $limit Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param  string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param  string $cursor Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeltaAsync($limit = null, $attributes = null, $cursor = null)
    {
        return $this->getDeltaAsyncWithHttpInfo($limit, $attributes, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeltaAsyncWithHttpInfo
     *
     * Delta stream with cursor support.
     *
     * @param  float $limit Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param  string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param  string $cursor Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeltaAsyncWithHttpInfo($limit = null, $attributes = null, $cursor = null)
    {
        $returnType = '\Balloon\Sdk\Model\Delta';
        $request = $this->getDeltaRequest($limit, $attributes, $cursor);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDelta'
     *
     * @param  float $limit Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param  string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param  string $cursor Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeltaPrepareRequest($limit = null, $attributes = null, $cursor = null)
    {

        $resourcePath = '/api/v2/nodes/delta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEventLog
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\EventLogs
     */
    public function getEventLog($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';

        try {
            try {
                $response = $this->getEventLogRequest($query, $attributes, $offset, $limit, $sort);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\EventLogs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getEventLogWithHttpInfo
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\EventLogs, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEventLogRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $request = $this->getEventLogPrepareRequest($query, $attributes, $offset, $limit, $sort);
        return $this->client->send($request);
    }

    /**
     * Operation getEventLogAsync
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventLogAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getEventLogAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEventLogAsyncWithHttpInfo
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventLogAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';
        $request = $this->getEventLogRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEventLog'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEventLogPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {

        $resourcePath = '/api/v2/nodes/event-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileHistory
     *
     * Get a full change history of a file
     *
     * @param  string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\FileHistory
     */
    public function getFileHistory($file)
    {
        $returnType = '\Balloon\Sdk\Model\FileHistory';

        try {
            try {
                $response = $this->getFileHistoryRequest($file);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\FileHistory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getFileHistoryWithHttpInfo
     *
     * Get a full change history of a file
     *
     * @param  string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\FileHistory, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileHistoryRequest($file)
    {
        $request = $this->getFileHistoryPrepareRequest($file);
        return $this->client->send($request);
    }

    /**
     * Operation getFileHistoryAsync
     *
     * Get a full change history of a file
     *
     * @param  string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileHistoryAsync($file)
    {
        return $this->getFileHistoryAsyncWithHttpInfo($file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileHistoryAsyncWithHttpInfo
     *
     * Get a full change history of a file
     *
     * @param  string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileHistoryAsyncWithHttpInfo($file)
    {
        $returnType = '\Balloon\Sdk\Model\FileHistory';
        $request = $this->getFileHistoryRequest($file);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileHistory'
     *
     * @param  string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileHistoryPrepareRequest($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling getFileHistory'
            );
        }

        $resourcePath = '/api/v2/files/{file}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($file !== null) {
            $resourcePath = str_replace(
                '{' . 'file' . '}',
                ObjectSerializer::toPathValue($file),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFiles
     *
     * Get all files
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Files
     */
    public function getFiles($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Files';

        try {
            try {
                $response = $this->getFilesRequest($query, $attributes, $offset, $limit, $sort, $deleted);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getFilesWithHttpInfo
     *
     * Get all files
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $request = $this->getFilesPrepareRequest($query, $attributes, $offset, $limit, $sort, $deleted);
        return $this->client->send($request);
    }

    /**
     * Operation getFilesAsync
     *
     * Get all files
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        return $this->getFilesAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort, $deleted)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesAsyncWithHttpInfo
     *
     * Get all files
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Files';
        $request = $this->getFilesRequest($query, $attributes, $offset, $limit, $sort, $deleted);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFiles'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFilesPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {

        $resourcePath = '/api/v2/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($deleted !== null) {
            $queryParams['deleted'] = ObjectSerializer::toQueryValue($deleted);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroup
     *
     * Get single group
     *
     * @param  string $group Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Group
     */
    public function getGroup($group, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';

        try {
            try {
                $response = $this->getGroupRequest($group, $attributes);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getGroupWithHttpInfo
     *
     * Get single group
     *
     * @param  string $group Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupRequest($group, $attributes = null)
    {
        $request = $this->getGroupPrepareRequest($group, $attributes);
        return $this->client->send($request);
    }

    /**
     * Operation getGroupAsync
     *
     * Get single group
     *
     * @param  string $group Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsync($group, $attributes = null)
    {
        return $this->getGroupAsyncWithHttpInfo($group, $attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupAsyncWithHttpInfo
     *
     * Get single group
     *
     * @param  string $group Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsyncWithHttpInfo($group, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->getGroupRequest($group, $attributes);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroup'
     *
     * @param  string $group Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupPrepareRequest($group, $attributes = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupMembers
     *
     * Request all member of a group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\User[]
     */
    public function getGroupMembers($group)
    {
        $returnType = '\Balloon\Sdk\Model\User[]';

        try {
            try {
                $response = $this->getGroupMembersRequest($group);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getGroupMembersWithHttpInfo
     *
     * Request all member of a group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\User[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMembersRequest($group)
    {
        $request = $this->getGroupMembersPrepareRequest($group);
        return $this->client->send($request);
    }

    /**
     * Operation getGroupMembersAsync
     *
     * Request all member of a group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersAsync($group)
    {
        return $this->getGroupMembersAsyncWithHttpInfo($group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMembersAsyncWithHttpInfo
     *
     * Request all member of a group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersAsyncWithHttpInfo($group)
    {
        $returnType = '\Balloon\Sdk\Model\User[]';
        $request = $this->getGroupMembersRequest($group);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupMembers'
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupMembersPrepareRequest($group)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getGroupMembers'
            );
        }

        $resourcePath = '/api/v2/groups/{group}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroups
     *
     * Get groups
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Groups
     */
    public function getGroups($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';

        try {
            try {
                $response = $this->getGroupsRequest($query, $attributes, $offset, $limit, $sort);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Groups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getGroupsWithHttpInfo
     *
     * Get groups
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Groups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupsRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $request = $this->getGroupsPrepareRequest($query, $attributes, $offset, $limit, $sort);
        return $this->client->send($request);
    }

    /**
     * Operation getGroupsAsync
     *
     * Get groups
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupsAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getGroupsAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupsAsyncWithHttpInfo
     *
     * Get groups
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupsAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';
        $request = $this->getGroupsRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroups'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupsPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {

        $resourcePath = '/api/v2/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLastCursor
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getLastCursor()
    {
        $returnType = 'string';

        try {
            try {
                $response = $this->getLastCursorRequest();
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getLastCursorWithHttpInfo
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLastCursorRequest()
    {
        $request = $this->getLastCursorPrepareRequest();
        return $this->client->send($request);
    }

    /**
     * Operation getLastCursorAsync
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLastCursorAsync()
    {
        return $this->getLastCursorAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLastCursorAsyncWithHttpInfo
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLastCursorAsyncWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->getLastCursorRequest();

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLastCursor'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLastCursorPrepareRequest()
    {

        $resourcePath = '/api/v2/nodes/last-cursor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNode
     *
     * Get single node
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Node
     */
    public function getNode($node, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Node';

        try {
            try {
                $response = $this->getNodeRequest($node, $attributes);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getNodeWithHttpInfo
     *
     * Get single node
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeRequest($node, $attributes = null)
    {
        $request = $this->getNodePrepareRequest($node, $attributes);
        return $this->client->send($request);
    }

    /**
     * Operation getNodeAsync
     *
     * Get single node
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsync($node, $attributes = null)
    {
        return $this->getNodeAsyncWithHttpInfo($node, $attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeAsyncWithHttpInfo
     *
     * Get single node
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsyncWithHttpInfo($node, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->getNodeRequest($node, $attributes);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNode'
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodePrepareRequest($node, $attributes = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling getNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNodeAttributeSummary
     *
     * Get summary of node usage.
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\UserNodeAttributeSummary
     */
    public function getNodeAttributeSummary($user)
    {
        $returnType = '\Balloon\Sdk\Model\UserNodeAttributeSummary';

        try {
            try {
                $response = $this->getNodeAttributeSummaryRequest($user);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\UserNodeAttributeSummary',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getNodeAttributeSummaryWithHttpInfo
     *
     * Get summary of node usage.
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\UserNodeAttributeSummary, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeAttributeSummaryRequest($user)
    {
        $request = $this->getNodeAttributeSummaryPrepareRequest($user);
        return $this->client->send($request);
    }

    /**
     * Operation getNodeAttributeSummaryAsync
     *
     * Get summary of node usage.
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAttributeSummaryAsync($user)
    {
        return $this->getNodeAttributeSummaryAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeAttributeSummaryAsyncWithHttpInfo
     *
     * Get summary of node usage.
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAttributeSummaryAsyncWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\UserNodeAttributeSummary';
        $request = $this->getNodeAttributeSummaryRequest($user);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNodeAttributeSummary'
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeAttributeSummaryPrepareRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getNodeAttributeSummary'
            );
        }

        $resourcePath = '/api/v2/users/{user}/node-attribute-summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNodeEventLog
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param  string $node Node identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\EventLogs
     */
    public function getNodeEventLog($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';

        try {
            try {
                $response = $this->getNodeEventLogRequest($node, $query, $attributes, $offset, $limit, $sort);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\EventLogs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getNodeEventLogWithHttpInfo
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param  string $node Node identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\EventLogs, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeEventLogRequest($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $request = $this->getNodeEventLogPrepareRequest($node, $query, $attributes, $offset, $limit, $sort);
        return $this->client->send($request);
    }

    /**
     * Operation getNodeEventLogAsync
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param  string $node Node identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeEventLogAsync($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getNodeEventLogAsyncWithHttpInfo($node, $query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeEventLogAsyncWithHttpInfo
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param  string $node Node identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeEventLogAsyncWithHttpInfo($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';
        $request = $this->getNodeEventLogRequest($node, $query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNodeEventLog'
     *
     * @param  string $node Node identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeEventLogPrepareRequest($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling getNodeEventLog'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/event-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNodes
     *
     * Get all nodes
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getNodes($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';

        try {
            try {
                $response = $this->getNodesRequest($query, $attributes, $offset, $limit, $sort, $deleted);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getNodesWithHttpInfo
     *
     * Get all nodes
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodesRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $request = $this->getNodesPrepareRequest($query, $attributes, $offset, $limit, $sort, $deleted);
        return $this->client->send($request);
    }

    /**
     * Operation getNodesAsync
     *
     * Get all nodes
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodesAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        return $this->getNodesAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort, $deleted)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodesAsyncWithHttpInfo
     *
     * Get all nodes
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodesAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getNodesRequest($query, $attributes, $offset, $limit, $sort, $deleted);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNodes'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  float $deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodesPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {

        $resourcePath = '/api/v2/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($deleted !== null) {
            $queryParams['deleted'] = ObjectSerializer::toQueryValue($deleted);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getParentNodes
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  bool $self Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getParentNodes($node, $attributes = null, $self = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';

        try {
            try {
                $response = $this->getParentNodesRequest($node, $attributes, $self);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getParentNodesWithHttpInfo
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  bool $self Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParentNodesRequest($node, $attributes = null, $self = null)
    {
        $request = $this->getParentNodesPrepareRequest($node, $attributes, $self);
        return $this->client->send($request);
    }

    /**
     * Operation getParentNodesAsync
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  bool $self Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParentNodesAsync($node, $attributes = null, $self = null)
    {
        return $this->getParentNodesAsyncWithHttpInfo($node, $attributes, $self)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParentNodesAsyncWithHttpInfo
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  bool $self Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParentNodesAsyncWithHttpInfo($node, $attributes = null, $self = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getParentNodesRequest($node, $attributes, $self);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParentNodes'
     *
     * @param  string $node Node identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  bool $self Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParentNodesPrepareRequest($node, $attributes = null, $self = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling getParentNodes'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/parents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($self !== null) {
            $queryParams['self'] = ObjectSerializer::toQueryValue($self);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRootChildren
     *
     * Get all children of the root collection
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getRootChildren($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';

        try {
            try {
                $response = $this->getRootChildrenRequest($query, $attributes, $offset, $limit, $sort, $recursive);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getRootChildrenWithHttpInfo
     *
     * Get all children of the root collection
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRootChildrenRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $request = $this->getRootChildrenPrepareRequest($query, $attributes, $offset, $limit, $sort, $recursive);
        return $this->client->send($request);
    }

    /**
     * Operation getRootChildrenAsync
     *
     * Get all children of the root collection
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootChildrenAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        return $this->getRootChildrenAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort, $recursive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRootChildrenAsyncWithHttpInfo
     *
     * Get all children of the root collection
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootChildrenAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getRootChildrenRequest($query, $attributes, $offset, $limit, $sort, $recursive);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRootChildren'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param  bool $recursive Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRootChildrenPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {

        $resourcePath = '/api/v2/collections/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($recursive !== null) {
            $queryParams['recursive'] = ObjectSerializer::toQueryValue($recursive);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getShare
     *
     * Get share acl and share name
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Share
     */
    public function getShare($collection)
    {
        $returnType = '\Balloon\Sdk\Model\Share';

        try {
            try {
                $response = $this->getShareRequest($collection);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Share',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getShareWithHttpInfo
     *
     * Get share acl and share name
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Share, HTTP status code, HTTP response headers (array of strings)
     */
    public function getShareRequest($collection)
    {
        $request = $this->getSharePrepareRequest($collection);
        return $this->client->send($request);
    }

    /**
     * Operation getShareAsync
     *
     * Get share acl and share name
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShareAsync($collection)
    {
        return $this->getShareAsyncWithHttpInfo($collection)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getShareAsyncWithHttpInfo
     *
     * Get share acl and share name
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShareAsyncWithHttpInfo($collection)
    {
        $returnType = '\Balloon\Sdk\Model\Share';
        $request = $this->getShareRequest($collection);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getShare'
     *
     * @param  string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSharePrepareRequest($collection)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling getShare'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{' . 'collection' . '}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUser
     *
     * Get single user
     *
     * @param  string $user Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\User
     */
    public function getUser($user, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';

        try {
            try {
                $response = $this->getUserRequest($user, $attributes);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getUserWithHttpInfo
     *
     * Get single user
     *
     * @param  string $user Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserRequest($user, $attributes = null)
    {
        $request = $this->getUserPrepareRequest($user, $attributes);
        return $this->client->send($request);
    }

    /**
     * Operation getUserAsync
     *
     * Get single user
     *
     * @param  string $user Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsync($user, $attributes = null)
    {
        return $this->getUserAsyncWithHttpInfo($user, $attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAsyncWithHttpInfo
     *
     * Get single user
     *
     * @param  string $user Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsyncWithHttpInfo($user, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getUserRequest($user, $attributes);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUser'
     *
     * @param  string $user Resource identifier (required)
     * @param  string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserPrepareRequest($user, $attributes = null)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserAvatar
     *
     * Get user avatar
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\User
     */
    public function getUserAvatar($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';

        try {
            try {
                $response = $this->getUserAvatarRequest($user);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getUserAvatarWithHttpInfo
     *
     * Get user avatar
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserAvatarRequest($user)
    {
        $request = $this->getUserAvatarPrepareRequest($user);
        return $this->client->send($request);
    }

    /**
     * Operation getUserAvatarAsync
     *
     * Get user avatar
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAvatarAsync($user)
    {
        return $this->getUserAvatarAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAvatarAsyncWithHttpInfo
     *
     * Get user avatar
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAvatarAsyncWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getUserAvatarRequest($user);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserAvatar'
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserAvatarPrepareRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getUserAvatar'
            );
        }

        $resourcePath = '/api/v2/users/{user}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['octet/stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['octet/stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserGroups
     *
     * Request all groups of a user
     *
     * @param  string $user Resource identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Groups
     */
    public function getUserGroups($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';

        try {
            try {
                $response = $this->getUserGroupsRequest($user, $query, $attributes, $offset, $limit, $sort);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Groups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getUserGroupsWithHttpInfo
     *
     * Request all groups of a user
     *
     * @param  string $user Resource identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Groups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserGroupsRequest($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $request = $this->getUserGroupsPrepareRequest($user, $query, $attributes, $offset, $limit, $sort);
        return $this->client->send($request);
    }

    /**
     * Operation getUserGroupsAsync
     *
     * Request all groups of a user
     *
     * @param  string $user Resource identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserGroupsAsync($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getUserGroupsAsyncWithHttpInfo($user, $query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserGroupsAsyncWithHttpInfo
     *
     * Request all groups of a user
     *
     * @param  string $user Resource identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserGroupsAsyncWithHttpInfo($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';
        $request = $this->getUserGroupsRequest($user, $query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserGroups'
     *
     * @param  string $user Resource identifier (required)
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserGroupsPrepareRequest($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getUserGroups'
            );
        }

        $resourcePath = '/api/v2/users/{user}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUsers
     *
     * Get users
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Users[]
     */
    public function getUsers($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Users[]';

        try {
            try {
                $response = $this->getUsersRequest($query, $attributes, $offset, $limit, $sort);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Users[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getUsersWithHttpInfo
     *
     * Get users
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Users[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getUsersRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $request = $this->getUsersPrepareRequest($query, $attributes, $offset, $limit, $sort);
        return $this->client->send($request);
    }

    /**
     * Operation getUsersAsync
     *
     * Get users
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getUsersAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUsersAsyncWithHttpInfo
     *
     * Get users
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Users[]';
        $request = $this->getUsersRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUsers'
     *
     * @param  string $query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param  string[] $attributes Filter attributes (optional)
     * @param  float $offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param  float $limit Objects limit, per default 20 objects will get returned (optional)
     * @param  string $sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUsersPrepareRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {

        $resourcePath = '/api/v2/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getV2
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\ApiRoot
     */
    public function getV2()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';

        try {
            try {
                $response = $this->getV2Request();
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\ApiRoot',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation getV2WithHttpInfo
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\ApiRoot, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV2Request()
    {
        $request = $this->getV2PrepareRequest();
        return $this->client->send($request);
    }

    /**
     * Operation getV2Async
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV2Async()
    {
        return $this->getV2AsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV2AsyncWithHttpInfo
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV2AsyncWithHttpInfo()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';
        $request = $this->getV2Request();

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getV2'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV2PrepareRequest()
    {

        $resourcePath = '/api/v2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveNode
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Node
     */
    public function moveNode($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';

        try {
            try {
                $response = $this->moveNodeRequest($node, $destid, $conflict);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation moveNodeWithHttpInfo
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveNodeRequest($node, $destid = null, $conflict = '0')
    {
        $request = $this->moveNodePrepareRequest($node, $destid, $conflict);
        return $this->client->send($request);
    }

    /**
     * Operation moveNodeAsync
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveNodeAsync($node, $destid = null, $conflict = '0')
    {
        return $this->moveNodeAsyncWithHttpInfo($node, $destid, $conflict)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveNodeAsyncWithHttpInfo
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveNodeAsyncWithHttpInfo($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->moveNodeRequest($node, $destid, $conflict);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveNode'
     *
     * @param  string $node Node identifier (required)
     * @param  string $destid Destination collection, if this is null root is taken (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function moveNodePrepareRequest($node, $destid = null, $conflict = '0')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling moveNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($destid !== null) {
            $queryParams['destid'] = ObjectSerializer::toQueryValue($destid);
        }
        // query params
        if ($conflict !== null) {
            $queryParams['conflict'] = ObjectSerializer::toQueryValue($conflict);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchGroup
     *
     * Set attributes for group
     *
     * @param  string $group Resource identifier (required)
     * @param  \Balloon\Sdk\Model\Group $body Set attributes for group (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Group
     */
    public function patchGroup($group, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Group';

        try {
            try {
                $response = $this->patchGroupRequest($group, $body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation patchGroupWithHttpInfo
     *
     * Set attributes for group
     *
     * @param  string $group Resource identifier (required)
     * @param  \Balloon\Sdk\Model\Group $body Set attributes for group (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchGroupRequest($group, $body)
    {
        $request = $this->patchGroupPrepareRequest($group, $body);
        return $this->client->send($request);
    }

    /**
     * Operation patchGroupAsync
     *
     * Set attributes for group
     *
     * @param  string $group Resource identifier (required)
     * @param  \Balloon\Sdk\Model\Group $body Set attributes for group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchGroupAsync($group, $body)
    {
        return $this->patchGroupAsyncWithHttpInfo($group, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchGroupAsyncWithHttpInfo
     *
     * Set attributes for group
     *
     * @param  string $group Resource identifier (required)
     * @param  \Balloon\Sdk\Model\Group $body Set attributes for group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchGroupAsyncWithHttpInfo($group, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->patchGroupRequest($group, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchGroup'
     *
     * @param  string $group Resource identifier (required)
     * @param  \Balloon\Sdk\Model\Group $body Set attributes for group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchGroupPrepareRequest($group, $body)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling patchGroup'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchUser
     *
     * Set attributes for user
     *
     * @param  string $user Resource identifier (required)
     * @param  \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\User
     */
    public function patchUser($user, $body)
    {
        $returnType = '\Balloon\Sdk\Model\User';

        try {
            try {
                $response = $this->patchUserRequest($user, $body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation patchUserWithHttpInfo
     *
     * Set attributes for user
     *
     * @param  string $user Resource identifier (required)
     * @param  \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchUserRequest($user, $body)
    {
        $request = $this->patchUserPrepareRequest($user, $body);
        return $this->client->send($request);
    }

    /**
     * Operation patchUserAsync
     *
     * Set attributes for user
     *
     * @param  string $user Resource identifier (required)
     * @param  \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchUserAsync($user, $body)
    {
        return $this->patchUserAsyncWithHttpInfo($user, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchUserAsyncWithHttpInfo
     *
     * Set attributes for user
     *
     * @param  string $user Resource identifier (required)
     * @param  \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchUserAsyncWithHttpInfo($user, $body)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->patchUserRequest($user, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchUser'
     *
     * @param  string $user Resource identifier (required)
     * @param  \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchUserPrepareRequest($user, $body)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling patchUser'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rollbackFile
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param  string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\File
     */
    public function rollbackFile($file)
    {
        $returnType = '\Balloon\Sdk\Model\File';

        try {
            try {
                $response = $this->rollbackFileRequest($file);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation rollbackFileWithHttpInfo
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param  string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\File, HTTP status code, HTTP response headers (array of strings)
     */
    public function rollbackFileRequest($file)
    {
        $request = $this->rollbackFilePrepareRequest($file);
        return $this->client->send($request);
    }

    /**
     * Operation rollbackFileAsync
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param  string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbackFileAsync($file)
    {
        return $this->rollbackFileAsyncWithHttpInfo($file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rollbackFileAsyncWithHttpInfo
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param  string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbackFileAsyncWithHttpInfo($file)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->rollbackFileRequest($file);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rollbackFile'
     *
     * @param  string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rollbackFilePrepareRequest($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling rollbackFile'
            );
        }

        $resourcePath = '/api/v2/files/{file}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($file !== null) {
            $resourcePath = str_replace(
                '{' . 'file' . '}',
                ObjectSerializer::toPathValue($file),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shareCollection
     *
     * Create a new share from an existing collection
     *
     * @param  string $collection Collection identifier (required)
     * @param  \Balloon\Sdk\Model\Share $body Create a new share from an existing collection (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Collection
     */
    public function shareCollection($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';

        try {
            try {
                $response = $this->shareCollectionRequest($collection, $body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation shareCollectionWithHttpInfo
     *
     * Create a new share from an existing collection
     *
     * @param  string $collection Collection identifier (required)
     * @param  \Balloon\Sdk\Model\Share $body Create a new share from an existing collection (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Collection, HTTP status code, HTTP response headers (array of strings)
     */
    public function shareCollectionRequest($collection, $body)
    {
        $request = $this->shareCollectionPrepareRequest($collection, $body);
        return $this->client->send($request);
    }

    /**
     * Operation shareCollectionAsync
     *
     * Create a new share from an existing collection
     *
     * @param  string $collection Collection identifier (required)
     * @param  \Balloon\Sdk\Model\Share $body Create a new share from an existing collection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareCollectionAsync($collection, $body)
    {
        return $this->shareCollectionAsyncWithHttpInfo($collection, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shareCollectionAsyncWithHttpInfo
     *
     * Create a new share from an existing collection
     *
     * @param  string $collection Collection identifier (required)
     * @param  \Balloon\Sdk\Model\Share $body Create a new share from an existing collection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareCollectionAsyncWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->shareCollectionRequest($collection, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shareCollection'
     *
     * @param  string $collection Collection identifier (required)
     * @param  \Balloon\Sdk\Model\Share $body Create a new share from an existing collection (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shareCollectionPrepareRequest($collection, $body)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling shareCollection'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shareCollection'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{' . 'collection' . '}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation undeleteGroup
     *
     * Restore deleted group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Group
     */
    public function undeleteGroup($group)
    {
        $returnType = '\Balloon\Sdk\Model\Group';

        try {
            try {
                $response = $this->undeleteGroupRequest($group);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation undeleteGroupWithHttpInfo
     *
     * Restore deleted group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function undeleteGroupRequest($group)
    {
        $request = $this->undeleteGroupPrepareRequest($group);
        return $this->client->send($request);
    }

    /**
     * Operation undeleteGroupAsync
     *
     * Restore deleted group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteGroupAsync($group)
    {
        return $this->undeleteGroupAsyncWithHttpInfo($group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation undeleteGroupAsyncWithHttpInfo
     *
     * Restore deleted group
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteGroupAsyncWithHttpInfo($group)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->undeleteGroupRequest($group);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'undeleteGroup'
     *
     * @param  string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function undeleteGroupPrepareRequest($group)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling undeleteGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}/undelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation undeleteNode
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param  string $node Node identifier (required)
     * @param  bool $move If node should also be moved during undelete (optional, default to false)
     * @param  string $destid If node should also be moved during undelete (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Node
     */
    public function undeleteNode($node, $move = 'false', $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';

        try {
            try {
                $response = $this->undeleteNodeRequest($node, $move, $destid, $conflict);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation undeleteNodeWithHttpInfo
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param  string $node Node identifier (required)
     * @param  bool $move If node should also be moved during undelete (optional, default to false)
     * @param  string $destid If node should also be moved during undelete (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function undeleteNodeRequest($node, $move = 'false', $destid = null, $conflict = '0')
    {
        $request = $this->undeleteNodePrepareRequest($node, $move, $destid, $conflict);
        return $this->client->send($request);
    }

    /**
     * Operation undeleteNodeAsync
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param  string $node Node identifier (required)
     * @param  bool $move If node should also be moved during undelete (optional, default to false)
     * @param  string $destid If node should also be moved during undelete (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteNodeAsync($node, $move = 'false', $destid = null, $conflict = '0')
    {
        return $this->undeleteNodeAsyncWithHttpInfo($node, $move, $destid, $conflict)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation undeleteNodeAsyncWithHttpInfo
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param  string $node Node identifier (required)
     * @param  bool $move If node should also be moved during undelete (optional, default to false)
     * @param  string $destid If node should also be moved during undelete (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteNodeAsyncWithHttpInfo($node, $move = 'false', $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->undeleteNodeRequest($node, $move, $destid, $conflict);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'undeleteNode'
     *
     * @param  string $node Node identifier (required)
     * @param  bool $move If node should also be moved during undelete (optional, default to false)
     * @param  string $destid If node should also be moved during undelete (optional)
     * @param  float $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function undeleteNodePrepareRequest($node, $move = 'false', $destid = null, $conflict = '0')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling undeleteNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/undelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($move !== null) {
            $queryParams['move'] = ObjectSerializer::toQueryValue($move);
        }
        // query params
        if ($destid !== null) {
            $queryParams['destid'] = ObjectSerializer::toQueryValue($destid);
        }
        // query params
        if ($conflict !== null) {
            $queryParams['conflict'] = ObjectSerializer::toQueryValue($conflict);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation undeleteUser
     *
     * Restore deleted user
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\User
     */
    public function undeleteUser($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';

        try {
            try {
                $response = $this->undeleteUserRequest($user);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation undeleteUserWithHttpInfo
     *
     * Restore deleted user
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function undeleteUserRequest($user)
    {
        $request = $this->undeleteUserPrepareRequest($user);
        return $this->client->send($request);
    }

    /**
     * Operation undeleteUserAsync
     *
     * Restore deleted user
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteUserAsync($user)
    {
        return $this->undeleteUserAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation undeleteUserAsyncWithHttpInfo
     *
     * Restore deleted user
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteUserAsyncWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->undeleteUserRequest($user);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'undeleteUser'
     *
     * @param  string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function undeleteUserPrepareRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling undeleteUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}/undelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNode
     *
     * Change attributes
     *
     * @param  string $node Node identifier (required)
     * @param  \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\Node
     */
    public function updateNode($node, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Node';

        try {
            try {
                $response = $this->updateNodeRequest($node, $body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation updateNodeWithHttpInfo
     *
     * Change attributes
     *
     * @param  string $node Node identifier (required)
     * @param  \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNodeRequest($node, $body)
    {
        $request = $this->updateNodePrepareRequest($node, $body);
        return $this->client->send($request);
    }

    /**
     * Operation updateNodeAsync
     *
     * Change attributes
     *
     * @param  string $node Node identifier (required)
     * @param  \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNodeAsync($node, $body)
    {
        return $this->updateNodeAsyncWithHttpInfo($node, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNodeAsyncWithHttpInfo
     *
     * Change attributes
     *
     * @param  string $node Node identifier (required)
     * @param  \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNodeAsyncWithHttpInfo($node, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->updateNodeRequest($node, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNode'
     *
     * @param  string $node Node identifier (required)
     * @param  \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNodePrepareRequest($node, $body)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling updateNode'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadChunk
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param  string $body File content (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\File
     */
    public function uploadChunk($body)
    {
        $returnType = '\Balloon\Sdk\Model\File';

        try {
            try {
                $response = $this->uploadChunkRequest($body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 206:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\ChunkSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation uploadChunkWithHttpInfo
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param  string $body File content (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\File, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadChunkRequest($body)
    {
        $request = $this->uploadChunkPrepareRequest($body);
        return $this->client->send($request);
    }

    /**
     * Operation uploadChunkAsync
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param  string $body File content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadChunkAsync($body)
    {
        return $this->uploadChunkAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadChunkAsyncWithHttpInfo
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param  string $body File content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadChunkAsyncWithHttpInfo($body)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->uploadChunkRequest($body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadChunk'
     *
     * @param  string $body File content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadChunkPrepareRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadChunk'
            );
        }

        $resourcePath = '/api/v2/files/chunk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadFile
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param  string $body File content (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Balloon\Sdk\Model\File
     */
    public function uploadFile($body = null)
    {
        $returnType = '\Balloon\Sdk\Model\File';

        try {
            try {
                $response = $this->uploadFileRequest($body);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                return $responseBody;
            }
    
            return ObjectSerializer::deserialize(json_decode($responseBody->getContents()), $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation uploadFileWithHttpInfo
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param  string $body File content (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Balloon\Sdk\Model\File, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFileRequest($body = null)
    {
        $request = $this->uploadFilePrepareRequest($body);
        return $this->client->send($request);
    }

    /**
     * Operation uploadFileAsync
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param  string $body File content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsync($body = null)
    {
        return $this->uploadFileAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFileAsyncWithHttpInfo
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param  string $body File content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->uploadFileRequest($body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFile'
     *
     * @param  string $body File content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadFilePrepareRequest($body = null)
    {

        $resourcePath = '/api/v2/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        switch($this->config->getAuthMethod()) {
            default:
            case Configuration::AUTH_BASIC:
                if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
                    $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
                }
            case Configuration::AUTH_TOKEN:
                if ($this->config->getAccessToken() !== null) {
                    $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
                }
            break;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

}
