<?php

declare(strict_types=1);

/**
 * balloon
 *
 * @copyright   Copryright (c) 2019 gyselroth GmbH (https://gyselroth.com)
 * @license     MIT https://opensource.org/licenses/MIT
 */

/**
 * balloon API.
 *
 * balloon API
 *
 * OpenAPI spec version: 1.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Balloon\Sdk\Api;

use Balloon\Sdk\ApiException;
use Balloon\Sdk\Configuration;
use Balloon\Sdk\HeaderSelector;
use Balloon\Sdk\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * CoreV2Api Class Doc Comment.
 *
 * @category Class
 *
 * @author   Swagger Codegen team
 *
 * @see     https://github.com/swagger-api/swagger-codegen
 */
class CoreV2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addGroup.
     *
     * Add new group
     *
     * @param \Balloon\Sdk\Model\Group $data data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Group
     */
    public function addGroup($data = null)
    {
        list($response) = $this->addGroupWithHttpInfo($data);

        return $response;
    }

    /**
     * Operation addGroupWithHttpInfo.
     *
     * Add new group
     *
     * @param \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function addGroupWithHttpInfo($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->addGroupRequest($data);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation addGroupAsync.
     *
     * Add new group
     *
     * @param \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addGroupAsync($data = null)
    {
        return $this->addGroupAsyncWithHttpInfo($data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addGroupAsyncWithHttpInfo.
     *
     * Add new group
     *
     * @param \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addGroupAsyncWithHttpInfo($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->addGroupRequest($data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation addUser.
     *
     * Add new user
     *
     * @param \Balloon\Sdk\Model\User $data data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\User
     */
    public function addUser($data = null)
    {
        list($response) = $this->addUserWithHttpInfo($data);

        return $response;
    }

    /**
     * Operation addUserWithHttpInfo.
     *
     * Add new user
     *
     * @param \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function addUserWithHttpInfo($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->addUserRequest($data);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation addUserAsync.
     *
     * Add new user
     *
     * @param \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUserAsync($data = null)
    {
        return $this->addUserAsyncWithHttpInfo($data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addUserAsyncWithHttpInfo.
     *
     * Add new user
     *
     * @param \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUserAsyncWithHttpInfo($data = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->addUserRequest($data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation cloneNode.
     *
     * Clone existing node
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Node
     */
    public function cloneNode($node, $destid = null, $conflict = '0')
    {
        list($response) = $this->cloneNodeWithHttpInfo($node, $destid, $conflict);

        return $response;
    }

    /**
     * Operation cloneNodeWithHttpInfo.
     *
     * Clone existing node
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloneNodeWithHttpInfo($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->cloneNodeRequest($node, $destid, $conflict);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation cloneNodeAsync.
     *
     * Clone existing node
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneNodeAsync($node, $destid = null, $conflict = '0')
    {
        return $this->cloneNodeAsyncWithHttpInfo($node, $destid, $conflict)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloneNodeAsyncWithHttpInfo.
     *
     * Clone existing node
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneNodeAsyncWithHttpInfo($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->cloneNodeRequest($node, $destid, $conflict);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createCollection.
     *
     * Create a new collection
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       body (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Collection
     */
    public function createCollection($collection, $body)
    {
        list($response) = $this->createCollectionWithHttpInfo($collection, $body);

        return $response;
    }

    /**
     * Operation createCollectionWithHttpInfo.
     *
     * Create a new collection
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Collection, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCollectionWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->createCollectionRequest($collection, $body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createCollectionAsync.
     *
     * Create a new collection
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectionAsync($collection, $body)
    {
        return $this->createCollectionAsyncWithHttpInfo($collection, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCollectionAsyncWithHttpInfo.
     *
     * Create a new collection
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCollectionAsyncWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->createCollectionRequest($collection, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createRootCollection.
     *
     * Create a new collection in root
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       body (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Collection
     */
    public function createRootCollection($collection, $body)
    {
        list($response) = $this->createRootCollectionWithHttpInfo($collection, $body);

        return $response;
    }

    /**
     * Operation createRootCollectionWithHttpInfo.
     *
     * Create a new collection in root
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Collection, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRootCollectionWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->createRootCollectionRequest($collection, $body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createRootCollectionAsync.
     *
     * Create a new collection in root
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRootCollectionAsync($collection, $body)
    {
        return $this->createRootCollectionAsyncWithHttpInfo($collection, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRootCollectionAsyncWithHttpInfo.
     *
     * Create a new collection in root
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRootCollectionAsyncWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->createRootCollectionRequest($collection, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteGroup.
     *
     * Delete group
     *
     * @param string $group Resource identifier (required)
     * @param bool   $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function deleteGroup($group, $force = null)
    {
        $this->deleteGroupWithHttpInfo($group, $force);
    }

    /**
     * Operation deleteGroupWithHttpInfo.
     *
     * Delete group
     *
     * @param string $group Resource identifier (required)
     * @param bool   $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGroupWithHttpInfo($group, $force = null)
    {
        $returnType = '';
        $request = $this->deleteGroupRequest($group, $force);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation deleteGroupAsync.
     *
     * Delete group
     *
     * @param string $group Resource identifier (required)
     * @param bool   $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGroupAsync($group, $force = null)
    {
        return $this->deleteGroupAsyncWithHttpInfo($group, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGroupAsyncWithHttpInfo.
     *
     * Delete group
     *
     * @param string $group Resource identifier (required)
     * @param bool   $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGroupAsyncWithHttpInfo($group, $force = null)
    {
        $returnType = '';
        $request = $this->deleteGroupRequest($group, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteNode.
     *
     * Delete node
     *
     * @param string $node        Node identifier (required)
     * @param bool   $force       Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param bool   $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param float  $at          Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function deleteNode($node, $force = null, $ignore_flag = null, $at = null)
    {
        $this->deleteNodeWithHttpInfo($node, $force, $ignore_flag, $at);
    }

    /**
     * Operation deleteNodeWithHttpInfo.
     *
     * Delete node
     *
     * @param string $node        Node identifier (required)
     * @param bool   $force       Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param bool   $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param float  $at          Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNodeWithHttpInfo($node, $force = null, $ignore_flag = null, $at = null)
    {
        $returnType = '';
        $request = $this->deleteNodeRequest($node, $force, $ignore_flag, $at);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation deleteNodeAsync.
     *
     * Delete node
     *
     * @param string $node        Node identifier (required)
     * @param bool   $force       Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param bool   $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param float  $at          Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNodeAsync($node, $force = null, $ignore_flag = null, $at = null)
    {
        return $this->deleteNodeAsyncWithHttpInfo($node, $force, $ignore_flag, $at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNodeAsyncWithHttpInfo.
     *
     * Delete node
     *
     * @param string $node        Node identifier (required)
     * @param bool   $force       Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param bool   $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param float  $at          Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNodeAsyncWithHttpInfo($node, $force = null, $ignore_flag = null, $at = null)
    {
        $returnType = '';
        $request = $this->deleteNodeRequest($node, $force, $ignore_flag, $at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteShare.
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function deleteShare($collection)
    {
        $this->deleteShareWithHttpInfo($collection);
    }

    /**
     * Operation deleteShareWithHttpInfo.
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteShareWithHttpInfo($collection)
    {
        $returnType = '';
        $request = $this->deleteShareRequest($collection);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation deleteShareAsync.
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShareAsync($collection)
    {
        return $this->deleteShareAsyncWithHttpInfo($collection)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteShareAsyncWithHttpInfo.
     *
     * Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShareAsyncWithHttpInfo($collection)
    {
        $returnType = '';
        $request = $this->deleteShareRequest($collection);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteUser.
     *
     * Delete user
     *
     * @param string $user  Resource identifier (required)
     * @param bool   $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function deleteUser($user, $force = null)
    {
        $this->deleteUserWithHttpInfo($user, $force);
    }

    /**
     * Operation deleteUserWithHttpInfo.
     *
     * Delete user
     *
     * @param string $user  Resource identifier (required)
     * @param bool   $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserWithHttpInfo($user, $force = null)
    {
        $returnType = '';
        $request = $this->deleteUserRequest($user, $force);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation deleteUserAsync.
     *
     * Delete user
     *
     * @param string $user  Resource identifier (required)
     * @param bool   $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsync($user, $force = null)
    {
        return $this->deleteUserAsyncWithHttpInfo($user, $force)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserAsyncWithHttpInfo.
     *
     * Delete user
     *
     * @param string $user  Resource identifier (required)
     * @param bool   $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsyncWithHttpInfo($user, $force = null)
    {
        $returnType = '';
        $request = $this->deleteUserRequest($user, $force);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation downloadNode.
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param string $node        Node identifier (required)
     * @param float  $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param string $encode      Can be set to base64 to encode content as base64. (optional)
     * @param bool   $download    Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function downloadNode($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        $this->downloadNodeWithHttpInfo($node, $byte_ranges, $encode, $download);
    }

    /**
     * Operation downloadNodeWithHttpInfo.
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param string $node        Node identifier (required)
     * @param float  $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param string $encode      Can be set to base64 to encode content as base64. (optional)
     * @param bool   $download    Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadNodeWithHttpInfo($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        $returnType = '';
        $request = $this->downloadNodeRequest($node, $byte_ranges, $encode, $download);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation downloadNodeAsync.
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param string $node        Node identifier (required)
     * @param float  $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param string $encode      Can be set to base64 to encode content as base64. (optional)
     * @param bool   $download    Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadNodeAsync($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        return $this->downloadNodeAsyncWithHttpInfo($node, $byte_ranges, $encode, $download)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadNodeAsyncWithHttpInfo.
     *
     * Download node contents. Note that collections are zipped on-the-fly.
     *
     * @param string $node        Node identifier (required)
     * @param float  $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param string $encode      Can be set to base64 to encode content as base64. (optional)
     * @param bool   $download    Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadNodeAsyncWithHttpInfo($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        $returnType = '';
        $request = $this->downloadNodeRequest($node, $byte_ranges, $encode, $download);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getApi.
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\ApiRoot
     */
    public function getApi()
    {
        list($response) = $this->getApiWithHttpInfo();

        return $response;
    }

    /**
     * Operation getApiWithHttpInfo.
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\ApiRoot, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiWithHttpInfo()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';
        $request = $this->getApiRequest();

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\ApiRoot',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getApiAsync.
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiAsync()
    {
        return $this->getApiAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiAsyncWithHttpInfo.
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiAsyncWithHttpInfo()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';
        $request = $this->getApiRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getChildren.
     *
     * Get all children of a collection
     *
     * @param string   $collection Parent collection (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getChildren($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        list($response) = $this->getChildrenWithHttpInfo($collection, $query, $attributes, $offset, $limit, $sort, $recursive);

        return $response;
    }

    /**
     * Operation getChildrenWithHttpInfo.
     *
     * Get all children of a collection
     *
     * @param string   $collection Parent collection (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChildrenWithHttpInfo($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getChildrenRequest($collection, $query, $attributes, $offset, $limit, $sort, $recursive);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getChildrenAsync.
     *
     * Get all children of a collection
     *
     * @param string   $collection Parent collection (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAsync($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        return $this->getChildrenAsyncWithHttpInfo($collection, $query, $attributes, $offset, $limit, $sort, $recursive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChildrenAsyncWithHttpInfo.
     *
     * Get all children of a collection
     *
     * @param string   $collection Parent collection (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChildrenAsyncWithHttpInfo($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getChildrenRequest($collection, $query, $attributes, $offset, $limit, $sort, $recursive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getCollections.
     *
     * Get all collections
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Collections
     */
    public function getCollections($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        list($response) = $this->getCollectionsWithHttpInfo($query, $attributes, $offset, $limit, $sort);

        return $response;
    }

    /**
     * Operation getCollectionsWithHttpInfo.
     *
     * Get all collections
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Collections, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCollectionsWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Collections';
        $request = $this->getCollectionsRequest($query, $attributes, $offset, $limit, $sort);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collections',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getCollectionsAsync.
     *
     * Get all collections
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectionsAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getCollectionsAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCollectionsAsyncWithHttpInfo.
     *
     * Get all collections
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCollectionsAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Collections';
        $request = $this->getCollectionsRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getCurrentUser.
     *
     * Get user object of the current authenticated user
     *
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\User
     */
    public function getCurrentUser($attributes = null)
    {
        list($response) = $this->getCurrentUserWithHttpInfo($attributes);

        return $response;
    }

    /**
     * Operation getCurrentUserWithHttpInfo.
     *
     * Get user object of the current authenticated user
     *
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentUserWithHttpInfo($attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getCurrentUserRequest($attributes);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getCurrentUserAsync.
     *
     * Get user object of the current authenticated user
     *
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentUserAsync($attributes = null)
    {
        return $this->getCurrentUserAsyncWithHttpInfo($attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentUserAsyncWithHttpInfo.
     *
     * Get user object of the current authenticated user
     *
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentUserAsyncWithHttpInfo($attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getCurrentUserRequest($attributes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getDeletedNodes.
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getDeletedNodes($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        list($response) = $this->getDeletedNodesWithHttpInfo($query, $attributes, $offset, $limit, $sort);

        return $response;
    }

    /**
     * Operation getDeletedNodesWithHttpInfo.
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeletedNodesWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getDeletedNodesRequest($query, $attributes, $offset, $limit, $sort);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getDeletedNodesAsync.
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeletedNodesAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getDeletedNodesAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeletedNodesAsyncWithHttpInfo.
     *
     * Return delete nodes (Excluding sub nodes of deleted collections)
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeletedNodesAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getDeletedNodesRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getDelta.
     *
     * Delta stream with cursor support.
     *
     * @param float    $limit      Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param string   $cursor     Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Delta
     */
    public function getDelta($limit = null, $attributes = null, $cursor = null)
    {
        list($response) = $this->getDeltaWithHttpInfo($limit, $attributes, $cursor);

        return $response;
    }

    /**
     * Operation getDeltaWithHttpInfo.
     *
     * Delta stream with cursor support.
     *
     * @param float    $limit      Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param string   $cursor     Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Delta, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeltaWithHttpInfo($limit = null, $attributes = null, $cursor = null)
    {
        $returnType = '\Balloon\Sdk\Model\Delta';
        $request = $this->getDeltaRequest($limit, $attributes, $cursor);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Delta',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getDeltaAsync.
     *
     * Delta stream with cursor support.
     *
     * @param float    $limit      Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param string   $cursor     Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeltaAsync($limit = null, $attributes = null, $cursor = null)
    {
        return $this->getDeltaAsyncWithHttpInfo($limit, $attributes, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeltaAsyncWithHttpInfo.
     *
     * Delta stream with cursor support.
     *
     * @param float    $limit      Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param string   $cursor     Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeltaAsyncWithHttpInfo($limit = null, $attributes = null, $cursor = null)
    {
        $returnType = '\Balloon\Sdk\Model\Delta';
        $request = $this->getDeltaRequest($limit, $attributes, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getEventLog.
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\EventLogs
     */
    public function getEventLog($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        list($response) = $this->getEventLogWithHttpInfo($query, $attributes, $offset, $limit, $sort);

        return $response;
    }

    /**
     * Operation getEventLogWithHttpInfo.
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\EventLogs, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEventLogWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';
        $request = $this->getEventLogRequest($query, $attributes, $offset, $limit, $sort);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\EventLogs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getEventLogAsync.
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventLogAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getEventLogAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEventLogAsyncWithHttpInfo.
     *
     * Get event log containing all operations which are made by the user himself or share members
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventLogAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';
        $request = $this->getEventLogRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getFileHistory.
     *
     * Get a full change history of a file
     *
     * @param string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\FileHistory
     */
    public function getFileHistory($file)
    {
        list($response) = $this->getFileHistoryWithHttpInfo($file);

        return $response;
    }

    /**
     * Operation getFileHistoryWithHttpInfo.
     *
     * Get a full change history of a file
     *
     * @param string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\FileHistory, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileHistoryWithHttpInfo($file)
    {
        $returnType = '\Balloon\Sdk\Model\FileHistory';
        $request = $this->getFileHistoryRequest($file);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\FileHistory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getFileHistoryAsync.
     *
     * Get a full change history of a file
     *
     * @param string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileHistoryAsync($file)
    {
        return $this->getFileHistoryAsyncWithHttpInfo($file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileHistoryAsyncWithHttpInfo.
     *
     * Get a full change history of a file
     *
     * @param string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileHistoryAsyncWithHttpInfo($file)
    {
        $returnType = '\Balloon\Sdk\Model\FileHistory';
        $request = $this->getFileHistoryRequest($file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getFiles.
     *
     * Get all files
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Files
     */
    public function getFiles($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        list($response) = $this->getFilesWithHttpInfo($query, $attributes, $offset, $limit, $sort, $deleted);

        return $response;
    }

    /**
     * Operation getFilesWithHttpInfo.
     *
     * Get all files
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Files';
        $request = $this->getFilesRequest($query, $attributes, $offset, $limit, $sort, $deleted);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getFilesAsync.
     *
     * Get all files
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        return $this->getFilesAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort, $deleted)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesAsyncWithHttpInfo.
     *
     * Get all files
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Files';
        $request = $this->getFilesRequest($query, $attributes, $offset, $limit, $sort, $deleted);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getGroup.
     *
     * Get single group
     *
     * @param string   $group      Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Group
     */
    public function getGroup($group, $attributes = null)
    {
        list($response) = $this->getGroupWithHttpInfo($group, $attributes);

        return $response;
    }

    /**
     * Operation getGroupWithHttpInfo.
     *
     * Get single group
     *
     * @param string   $group      Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupWithHttpInfo($group, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->getGroupRequest($group, $attributes);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getGroupAsync.
     *
     * Get single group
     *
     * @param string   $group      Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsync($group, $attributes = null)
    {
        return $this->getGroupAsyncWithHttpInfo($group, $attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupAsyncWithHttpInfo.
     *
     * Get single group
     *
     * @param string   $group      Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsyncWithHttpInfo($group, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->getGroupRequest($group, $attributes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getGroupMembers.
     *
     * Request all member of a group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\User[]
     */
    public function getGroupMembers($group)
    {
        list($response) = $this->getGroupMembersWithHttpInfo($group);

        return $response;
    }

    /**
     * Operation getGroupMembersWithHttpInfo.
     *
     * Request all member of a group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\User[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMembersWithHttpInfo($group)
    {
        $returnType = '\Balloon\Sdk\Model\User[]';
        $request = $this->getGroupMembersRequest($group);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getGroupMembersAsync.
     *
     * Request all member of a group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersAsync($group)
    {
        return $this->getGroupMembersAsyncWithHttpInfo($group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMembersAsyncWithHttpInfo.
     *
     * Request all member of a group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersAsyncWithHttpInfo($group)
    {
        $returnType = '\Balloon\Sdk\Model\User[]';
        $request = $this->getGroupMembersRequest($group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getGroups.
     *
     * Get groups
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Groups
     */
    public function getGroups($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        list($response) = $this->getGroupsWithHttpInfo($query, $attributes, $offset, $limit, $sort);

        return $response;
    }

    /**
     * Operation getGroupsWithHttpInfo.
     *
     * Get groups
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Groups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupsWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';
        $request = $this->getGroupsRequest($query, $attributes, $offset, $limit, $sort);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Groups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getGroupsAsync.
     *
     * Get groups
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupsAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getGroupsAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupsAsyncWithHttpInfo.
     *
     * Get groups
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupsAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';
        $request = $this->getGroupsRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getLastCursor.
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return string
     */
    public function getLastCursor()
    {
        list($response) = $this->getLastCursorWithHttpInfo();

        return $response;
    }

    /**
     * Operation getLastCursorWithHttpInfo.
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLastCursorWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->getLastCursorRequest();

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getLastCursorAsync.
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLastCursorAsync()
    {
        return $this->getLastCursorAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLastCursorAsyncWithHttpInfo.
     *
     * Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLastCursorAsyncWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->getLastCursorRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getNode.
     *
     * Get single node
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Node
     */
    public function getNode($node, $attributes = null)
    {
        list($response) = $this->getNodeWithHttpInfo($node, $attributes);

        return $response;
    }

    /**
     * Operation getNodeWithHttpInfo.
     *
     * Get single node
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeWithHttpInfo($node, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->getNodeRequest($node, $attributes);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getNodeAsync.
     *
     * Get single node
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsync($node, $attributes = null)
    {
        return $this->getNodeAsyncWithHttpInfo($node, $attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeAsyncWithHttpInfo.
     *
     * Get single node
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsyncWithHttpInfo($node, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->getNodeRequest($node, $attributes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getNodeAttributeSummary.
     *
     * Get summary of node usage.
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\UserNodeAttributeSummary
     */
    public function getNodeAttributeSummary($user)
    {
        list($response) = $this->getNodeAttributeSummaryWithHttpInfo($user);

        return $response;
    }

    /**
     * Operation getNodeAttributeSummaryWithHttpInfo.
     *
     * Get summary of node usage.
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\UserNodeAttributeSummary, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeAttributeSummaryWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\UserNodeAttributeSummary';
        $request = $this->getNodeAttributeSummaryRequest($user);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\UserNodeAttributeSummary',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getNodeAttributeSummaryAsync.
     *
     * Get summary of node usage.
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAttributeSummaryAsync($user)
    {
        return $this->getNodeAttributeSummaryAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeAttributeSummaryAsyncWithHttpInfo.
     *
     * Get summary of node usage.
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAttributeSummaryAsyncWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\UserNodeAttributeSummary';
        $request = $this->getNodeAttributeSummaryRequest($user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getNodeEventLog.
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param string   $node       Node identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\EventLogs
     */
    public function getNodeEventLog($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        list($response) = $this->getNodeEventLogWithHttpInfo($node, $query, $attributes, $offset, $limit, $sort);

        return $response;
    }

    /**
     * Operation getNodeEventLogWithHttpInfo.
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param string   $node       Node identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\EventLogs, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeEventLogWithHttpInfo($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';
        $request = $this->getNodeEventLogRequest($node, $query, $attributes, $offset, $limit, $sort);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\EventLogs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getNodeEventLogAsync.
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param string   $node       Node identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeEventLogAsync($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getNodeEventLogAsyncWithHttpInfo($node, $query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeEventLogAsyncWithHttpInfo.
     *
     * Get event log containing all operations which are made by the user himself or share members on a given node
     *
     * @param string   $node       Node identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeEventLogAsyncWithHttpInfo($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\EventLogs';
        $request = $this->getNodeEventLogRequest($node, $query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getNodes.
     *
     * Get all nodes
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getNodes($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        list($response) = $this->getNodesWithHttpInfo($query, $attributes, $offset, $limit, $sort, $deleted);

        return $response;
    }

    /**
     * Operation getNodesWithHttpInfo.
     *
     * Get all nodes
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodesWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getNodesRequest($query, $attributes, $offset, $limit, $sort, $deleted);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getNodesAsync.
     *
     * Get all nodes
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodesAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        return $this->getNodesAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort, $deleted)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodesAsyncWithHttpInfo.
     *
     * Get all nodes
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodesAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getNodesRequest($query, $attributes, $offset, $limit, $sort, $deleted);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getParentNodes.
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     * @param bool     $self       Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getParentNodes($node, $attributes = null, $self = null)
    {
        list($response) = $this->getParentNodesWithHttpInfo($node, $attributes, $self);

        return $response;
    }

    /**
     * Operation getParentNodesWithHttpInfo.
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     * @param bool     $self       Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getParentNodesWithHttpInfo($node, $attributes = null, $self = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getParentNodesRequest($node, $attributes, $self);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getParentNodesAsync.
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     * @param bool     $self       Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParentNodesAsync($node, $attributes = null, $self = null)
    {
        return $this->getParentNodesAsyncWithHttpInfo($node, $attributes, $self)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParentNodesAsyncWithHttpInfo.
     *
     * The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     * @param bool     $self       Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParentNodesAsyncWithHttpInfo($node, $attributes = null, $self = null)
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getParentNodesRequest($node, $attributes, $self);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getRootChildren.
     *
     * Get all children of the root collection
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Nodes
     */
    public function getRootChildren($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        list($response) = $this->getRootChildrenWithHttpInfo($query, $attributes, $offset, $limit, $sort, $recursive);

        return $response;
    }

    /**
     * Operation getRootChildrenWithHttpInfo.
     *
     * Get all children of the root collection
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Nodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRootChildrenWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getRootChildrenRequest($query, $attributes, $offset, $limit, $sort, $recursive);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Nodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRootChildrenAsync.
     *
     * Get all children of the root collection
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootChildrenAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        return $this->getRootChildrenAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort, $recursive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRootChildrenAsyncWithHttpInfo.
     *
     * Get all children of the root collection
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootChildrenAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $returnType = '\Balloon\Sdk\Model\Nodes';
        $request = $this->getRootChildrenRequest($query, $attributes, $offset, $limit, $sort, $recursive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getShare.
     *
     * Get share acl and share name
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Share
     */
    public function getShare($collection)
    {
        list($response) = $this->getShareWithHttpInfo($collection);

        return $response;
    }

    /**
     * Operation getShareWithHttpInfo.
     *
     * Get share acl and share name
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Share, HTTP status code, HTTP response headers (array of strings)
     */
    public function getShareWithHttpInfo($collection)
    {
        $returnType = '\Balloon\Sdk\Model\Share';
        $request = $this->getShareRequest($collection);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Share',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getShareAsync.
     *
     * Get share acl and share name
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShareAsync($collection)
    {
        return $this->getShareAsyncWithHttpInfo($collection)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getShareAsyncWithHttpInfo.
     *
     * Get share acl and share name
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShareAsyncWithHttpInfo($collection)
    {
        $returnType = '\Balloon\Sdk\Model\Share';
        $request = $this->getShareRequest($collection);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getUser.
     *
     * Get single user
     *
     * @param string   $user       Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\User
     */
    public function getUser($user, $attributes = null)
    {
        list($response) = $this->getUserWithHttpInfo($user, $attributes);

        return $response;
    }

    /**
     * Operation getUserWithHttpInfo.
     *
     * Get single user
     *
     * @param string   $user       Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserWithHttpInfo($user, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getUserRequest($user, $attributes);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getUserAsync.
     *
     * Get single user
     *
     * @param string   $user       Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsync($user, $attributes = null)
    {
        return $this->getUserAsyncWithHttpInfo($user, $attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAsyncWithHttpInfo.
     *
     * Get single user
     *
     * @param string   $user       Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsyncWithHttpInfo($user, $attributes = null)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getUserRequest($user, $attributes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getUserAvatar.
     *
     * Get user avatar
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\User
     */
    public function getUserAvatar($user)
    {
        list($response) = $this->getUserAvatarWithHttpInfo($user);

        return $response;
    }

    /**
     * Operation getUserAvatarWithHttpInfo.
     *
     * Get user avatar
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserAvatarWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getUserAvatarRequest($user);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getUserAvatarAsync.
     *
     * Get user avatar
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAvatarAsync($user)
    {
        return $this->getUserAvatarAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAvatarAsyncWithHttpInfo.
     *
     * Get user avatar
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAvatarAsyncWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->getUserAvatarRequest($user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getUserGroups.
     *
     * Request all groups of a user
     *
     * @param string   $user       Resource identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Groups
     */
    public function getUserGroups($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        list($response) = $this->getUserGroupsWithHttpInfo($user, $query, $attributes, $offset, $limit, $sort);

        return $response;
    }

    /**
     * Operation getUserGroupsWithHttpInfo.
     *
     * Request all groups of a user
     *
     * @param string   $user       Resource identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Groups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserGroupsWithHttpInfo($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';
        $request = $this->getUserGroupsRequest($user, $query, $attributes, $offset, $limit, $sort);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Groups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getUserGroupsAsync.
     *
     * Request all groups of a user
     *
     * @param string   $user       Resource identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserGroupsAsync($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getUserGroupsAsyncWithHttpInfo($user, $query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserGroupsAsyncWithHttpInfo.
     *
     * Request all groups of a user
     *
     * @param string   $user       Resource identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserGroupsAsyncWithHttpInfo($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Groups';
        $request = $this->getUserGroupsRequest($user, $query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getUsers.
     *
     * Get users
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Users[]
     */
    public function getUsers($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        list($response) = $this->getUsersWithHttpInfo($query, $attributes, $offset, $limit, $sort);

        return $response;
    }

    /**
     * Operation getUsersWithHttpInfo.
     *
     * Get users
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Users[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getUsersWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Users[]';
        $request = $this->getUsersRequest($query, $attributes, $offset, $limit, $sort);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Users[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getUsersAsync.
     *
     * Get users
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsync($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        return $this->getUsersAsyncWithHttpInfo($query, $attributes, $offset, $limit, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUsersAsyncWithHttpInfo.
     *
     * Get users
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsyncWithHttpInfo($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $returnType = '\Balloon\Sdk\Model\Users[]';
        $request = $this->getUsersRequest($query, $attributes, $offset, $limit, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getV2.
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\ApiRoot
     */
    public function getV2()
    {
        list($response) = $this->getV2WithHttpInfo();

        return $response;
    }

    /**
     * Operation getV2WithHttpInfo.
     *
     * Get server status
     *
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\ApiRoot, HTTP status code, HTTP response headers (array of strings)
     */
    public function getV2WithHttpInfo()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';
        $request = $this->getV2Request();

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\ApiRoot',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getV2Async.
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV2Async()
    {
        return $this->getV2AsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getV2AsyncWithHttpInfo.
     *
     * Get server status
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getV2AsyncWithHttpInfo()
    {
        $returnType = '\Balloon\Sdk\Model\ApiRoot';
        $request = $this->getV2Request();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation moveNode.
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Node
     */
    public function moveNode($node, $destid = null, $conflict = '0')
    {
        list($response) = $this->moveNodeWithHttpInfo($node, $destid, $conflict);

        return $response;
    }

    /**
     * Operation moveNodeWithHttpInfo.
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveNodeWithHttpInfo($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->moveNodeRequest($node, $destid, $conflict);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation moveNodeAsync.
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveNodeAsync($node, $destid = null, $conflict = '0')
    {
        return $this->moveNodeAsyncWithHttpInfo($node, $destid, $conflict)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveNodeAsyncWithHttpInfo.
     *
     * Move node (Change parent collection), single or multiple ones
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveNodeAsyncWithHttpInfo($node, $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->moveNodeRequest($node, $destid, $conflict);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation patchGroup.
     *
     * Set attributes for group
     *
     * @param string                   $group Resource identifier (required)
     * @param \Balloon\Sdk\Model\Group $body  Set attributes for group (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Group
     */
    public function patchGroup($group, $body)
    {
        list($response) = $this->patchGroupWithHttpInfo($group, $body);

        return $response;
    }

    /**
     * Operation patchGroupWithHttpInfo.
     *
     * Set attributes for group
     *
     * @param string                   $group Resource identifier (required)
     * @param \Balloon\Sdk\Model\Group $body  Set attributes for group (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchGroupWithHttpInfo($group, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->patchGroupRequest($group, $body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation patchGroupAsync.
     *
     * Set attributes for group
     *
     * @param string                   $group Resource identifier (required)
     * @param \Balloon\Sdk\Model\Group $body  Set attributes for group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchGroupAsync($group, $body)
    {
        return $this->patchGroupAsyncWithHttpInfo($group, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchGroupAsyncWithHttpInfo.
     *
     * Set attributes for group
     *
     * @param string                   $group Resource identifier (required)
     * @param \Balloon\Sdk\Model\Group $body  Set attributes for group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchGroupAsyncWithHttpInfo($group, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->patchGroupRequest($group, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation patchUser.
     *
     * Set attributes for user
     *
     * @param string                  $user Resource identifier (required)
     * @param \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\User
     */
    public function patchUser($user, $body)
    {
        list($response) = $this->patchUserWithHttpInfo($user, $body);

        return $response;
    }

    /**
     * Operation patchUserWithHttpInfo.
     *
     * Set attributes for user
     *
     * @param string                  $user Resource identifier (required)
     * @param \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchUserWithHttpInfo($user, $body)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->patchUserRequest($user, $body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation patchUserAsync.
     *
     * Set attributes for user
     *
     * @param string                  $user Resource identifier (required)
     * @param \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchUserAsync($user, $body)
    {
        return $this->patchUserAsyncWithHttpInfo($user, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchUserAsyncWithHttpInfo.
     *
     * Set attributes for user
     *
     * @param string                  $user Resource identifier (required)
     * @param \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchUserAsyncWithHttpInfo($user, $body)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->patchUserRequest($user, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation rollbackFile.
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\File
     */
    public function rollbackFile($file)
    {
        list($response) = $this->rollbackFileWithHttpInfo($file);

        return $response;
    }

    /**
     * Operation rollbackFileWithHttpInfo.
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param string $file File identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\File, HTTP status code, HTTP response headers (array of strings)
     */
    public function rollbackFileWithHttpInfo($file)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->rollbackFileRequest($file);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation rollbackFileAsync.
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbackFileAsync($file)
    {
        return $this->rollbackFileAsyncWithHttpInfo($file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rollbackFileAsyncWithHttpInfo.
     *
     * Rollback to a recent version from history. Use the version number from history.
     *
     * @param string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbackFileAsyncWithHttpInfo($file)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->rollbackFileRequest($file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation shareCollection.
     *
     * Create a new share from an existing collection
     *
     * @param string                   $collection Collection identifier (required)
     * @param \Balloon\Sdk\Model\Share $body       Create a new share from an existing collection (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Collection
     */
    public function shareCollection($collection, $body)
    {
        list($response) = $this->shareCollectionWithHttpInfo($collection, $body);

        return $response;
    }

    /**
     * Operation shareCollectionWithHttpInfo.
     *
     * Create a new share from an existing collection
     *
     * @param string                   $collection Collection identifier (required)
     * @param \Balloon\Sdk\Model\Share $body       Create a new share from an existing collection (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Collection, HTTP status code, HTTP response headers (array of strings)
     */
    public function shareCollectionWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->shareCollectionRequest($collection, $body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Collection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation shareCollectionAsync.
     *
     * Create a new share from an existing collection
     *
     * @param string                   $collection Collection identifier (required)
     * @param \Balloon\Sdk\Model\Share $body       Create a new share from an existing collection (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareCollectionAsync($collection, $body)
    {
        return $this->shareCollectionAsyncWithHttpInfo($collection, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shareCollectionAsyncWithHttpInfo.
     *
     * Create a new share from an existing collection
     *
     * @param string                   $collection Collection identifier (required)
     * @param \Balloon\Sdk\Model\Share $body       Create a new share from an existing collection (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareCollectionAsyncWithHttpInfo($collection, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Collection';
        $request = $this->shareCollectionRequest($collection, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation undeleteGroup.
     *
     * Restore deleted group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Group
     */
    public function undeleteGroup($group)
    {
        list($response) = $this->undeleteGroupWithHttpInfo($group);

        return $response;
    }

    /**
     * Operation undeleteGroupWithHttpInfo.
     *
     * Restore deleted group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function undeleteGroupWithHttpInfo($group)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->undeleteGroupRequest($group);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation undeleteGroupAsync.
     *
     * Restore deleted group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteGroupAsync($group)
    {
        return $this->undeleteGroupAsyncWithHttpInfo($group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation undeleteGroupAsyncWithHttpInfo.
     *
     * Restore deleted group
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteGroupAsyncWithHttpInfo($group)
    {
        $returnType = '\Balloon\Sdk\Model\Group';
        $request = $this->undeleteGroupRequest($group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation undeleteNode.
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param string $node     Node identifier (required)
     * @param bool   $move     If node should also be moved during undelete (optional, default to false)
     * @param string $destid   If node should also be moved during undelete (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Node
     */
    public function undeleteNode($node, $move = 'false', $destid = null, $conflict = '0')
    {
        list($response) = $this->undeleteNodeWithHttpInfo($node, $move, $destid, $conflict);

        return $response;
    }

    /**
     * Operation undeleteNodeWithHttpInfo.
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param string $node     Node identifier (required)
     * @param bool   $move     If node should also be moved during undelete (optional, default to false)
     * @param string $destid   If node should also be moved during undelete (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function undeleteNodeWithHttpInfo($node, $move = 'false', $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->undeleteNodeRequest($node, $move, $destid, $conflict);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation undeleteNodeAsync.
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param string $node     Node identifier (required)
     * @param bool   $move     If node should also be moved during undelete (optional, default to false)
     * @param string $destid   If node should also be moved during undelete (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteNodeAsync($node, $move = 'false', $destid = null, $conflict = '0')
    {
        return $this->undeleteNodeAsyncWithHttpInfo($node, $move, $destid, $conflict)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation undeleteNodeAsyncWithHttpInfo.
     *
     * Undelete (Restore from trash) a single node or multiple ones.
     *
     * @param string $node     Node identifier (required)
     * @param bool   $move     If node should also be moved during undelete (optional, default to false)
     * @param string $destid   If node should also be moved during undelete (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteNodeAsyncWithHttpInfo($node, $move = 'false', $destid = null, $conflict = '0')
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->undeleteNodeRequest($node, $move, $destid, $conflict);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation undeleteUser.
     *
     * Restore deleted user
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\User
     */
    public function undeleteUser($user)
    {
        list($response) = $this->undeleteUserWithHttpInfo($user);

        return $response;
    }

    /**
     * Operation undeleteUserWithHttpInfo.
     *
     * Restore deleted user
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function undeleteUserWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->undeleteUserRequest($user);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation undeleteUserAsync.
     *
     * Restore deleted user
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteUserAsync($user)
    {
        return $this->undeleteUserAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation undeleteUserAsyncWithHttpInfo.
     *
     * Restore deleted user
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function undeleteUserAsyncWithHttpInfo($user)
    {
        $returnType = '\Balloon\Sdk\Model\User';
        $request = $this->undeleteUserRequest($user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateNode.
     *
     * Change attributes
     *
     * @param string                  $node Node identifier (required)
     * @param \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\Node
     */
    public function updateNode($node, $body)
    {
        list($response) = $this->updateNodeWithHttpInfo($node, $body);

        return $response;
    }

    /**
     * Operation updateNodeWithHttpInfo.
     *
     * Change attributes
     *
     * @param string                  $node Node identifier (required)
     * @param \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\Node, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNodeWithHttpInfo($node, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->updateNodeRequest($node, $body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\Node',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateNodeAsync.
     *
     * Change attributes
     *
     * @param string                  $node Node identifier (required)
     * @param \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNodeAsync($node, $body)
    {
        return $this->updateNodeAsyncWithHttpInfo($node, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNodeAsyncWithHttpInfo.
     *
     * Change attributes
     *
     * @param string                  $node Node identifier (required)
     * @param \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNodeAsyncWithHttpInfo($node, $body)
    {
        $returnType = '\Balloon\Sdk\Model\Node';
        $request = $this->updateNodeRequest($node, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation uploadChunk.
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param string $body File content (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\File
     */
    public function uploadChunk($body)
    {
        list($response) = $this->uploadChunkWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation uploadChunkWithHttpInfo.
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param string $body File content (required)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\File, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadChunkWithHttpInfo($body)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->uploadChunkRequest($body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
                case 206:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\ChunkSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation uploadChunkAsync.
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param string $body File content (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadChunkAsync($body)
    {
        return $this->uploadChunkAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadChunkAsyncWithHttpInfo.
     *
     * Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     *
     * @param string $body File content (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadChunkAsyncWithHttpInfo($body)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->uploadChunkRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation uploadFile.
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param string $body File content (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Balloon\Sdk\Model\File
     */
    public function uploadFile($body = null)
    {
        list($response) = $this->uploadFileWithHttpInfo($body);

        return $response;
    }

    /**
     * Operation uploadFileWithHttpInfo.
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param string $body File content (optional)
     *
     * @throws \Balloon\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Balloon\Sdk\Model\File, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFileWithHttpInfo($body = null)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->uploadFileRequest($body);

        try {
            $options = $this->createHttpClientOption();

            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Balloon\Sdk\Model\File',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation uploadFileAsync.
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param string $body File content (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsync($body = null)
    {
        return $this->uploadFileAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFileAsyncWithHttpInfo.
     *
     * Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     *
     * @param string $body File content (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Balloon\Sdk\Model\File';
        $request = $this->uploadFileRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addGroup'.
     *
     * @param \Balloon\Sdk\Model\Group $data (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addGroupRequest($data = null)
    {
        $resourcePath = '/api/v2/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'addUser'.
     *
     * @param \Balloon\Sdk\Model\User $data (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addUserRequest($data = null)
    {
        $resourcePath = '/api/v2/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'cloneNode'.
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cloneNodeRequest($node, $destid = null, $conflict = '0')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling cloneNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/clone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($destid !== null) {
            $queryParams['destid'] = ObjectSerializer::toQueryValue($destid);
        }
        // query params
        if ($conflict !== null) {
            $queryParams['conflict'] = ObjectSerializer::toQueryValue($conflict);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'createCollection'.
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCollectionRequest($collection, $body)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling createCollection'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createCollection'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{'.'collection'.'}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'createRootCollection'.
     *
     * @param string                        $collection Parent collection (required)
     * @param \Balloon\Sdk\Model\Collection $body       (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRootCollectionRequest($collection, $body)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling createRootCollection'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createRootCollection'
            );
        }

        $resourcePath = '/api/v2/collections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{'.'collection'.'}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteGroup'.
     *
     * @param string $group Resource identifier (required)
     * @param bool   $force Per default the group gets disabled, if force is set the group gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteGroupRequest($group, $force = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling deleteGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{'.'group'.'}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteNode'.
     *
     * @param string $node        Node identifier (required)
     * @param bool   $force       Force flag need to be set to delete a node from trash (node must have the deleted flag) (optional)
     * @param bool   $ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely (optional)
     * @param float  $at          Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNodeRequest($node, $force = null, $ignore_flag = null, $at = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling deleteNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force);
        }
        // query params
        if ($ignore_flag !== null) {
            $queryParams['ignore_flag'] = ObjectSerializer::toQueryValue($ignore_flag);
        }
        // query params
        if ($at !== null) {
            $queryParams['at'] = ObjectSerializer::toQueryValue($at);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteShare'.
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteShareRequest($collection)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling deleteShare'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{'.'collection'.'}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteUser'.
     *
     * @param string $user  Resource identifier (required)
     * @param bool   $force Per default the user gets disabled, if force is set the user gets removed completely. (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteUserRequest($user, $force = null)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling deleteUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($force !== null) {
            $queryParams['force'] = ObjectSerializer::toQueryValue($force);
        }

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{'.'user'.'}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'downloadNode'.
     *
     * @param string $node        Node identifier (required)
     * @param float  $byte_ranges Read stream from a specific offset/limit in bytes (optional)
     * @param string $encode      Can be set to base64 to encode content as base64. (optional)
     * @param bool   $download    Force download file (Content-Disposition: attachment HTTP header) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadNodeRequest($node, $byte_ranges = null, $encode = null, $download = 'false')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling downloadNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($encode !== null) {
            $queryParams['encode'] = ObjectSerializer::toQueryValue($encode);
        }
        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }
        // header params
        if ($byte_ranges !== null) {
            $headerParams['Byte-Ranges'] = ObjectSerializer::toHeaderValue($byte_ranges);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['octet/stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['octet/stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getApi'.
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiRequest()
    {
        $resourcePath = '/api';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getChildren'.
     *
     * @param string   $collection Parent collection (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChildrenRequest($collection, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling getChildren'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($recursive !== null) {
            $queryParams['recursive'] = ObjectSerializer::toQueryValue($recursive);
        }

        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{'.'collection'.'}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getCollections'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCollectionsRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $resourcePath = '/api/v2/collections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getCurrentUser'.
     *
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrentUserRequest($attributes = null)
    {
        $resourcePath = '/api/v2/users/whoami';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getDeletedNodes'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeletedNodesRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $resourcePath = '/api/v2/nodes/trash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getDelta'.
     *
     * @param float    $limit      Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often (optional)
     * @param string[] $attributes Filter attributes, per default not all attributes would be returned (optional)
     * @param string   $cursor     Set a cursor to rquest next nodes within delta processing (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeltaRequest($limit = null, $attributes = null, $cursor = null)
    {
        $resourcePath = '/api/v2/nodes/delta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getEventLog'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEventLogRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $resourcePath = '/api/v2/nodes/event-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getFileHistory'.
     *
     * @param string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileHistoryRequest($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling getFileHistory'
            );
        }

        $resourcePath = '/api/v2/files/{file}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($file !== null) {
            $resourcePath = str_replace(
                '{'.'file'.'}',
                ObjectSerializer::toPathValue($file),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getFiles'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFilesRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $resourcePath = '/api/v2/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($deleted !== null) {
            $queryParams['deleted'] = ObjectSerializer::toQueryValue($deleted);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getGroup'.
     *
     * @param string   $group      Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupRequest($group, $attributes = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{'.'group'.'}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getGroupMembers'.
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupMembersRequest($group)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getGroupMembers'
            );
        }

        $resourcePath = '/api/v2/groups/{group}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{'.'group'.'}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getGroups'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupsRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $resourcePath = '/api/v2/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getLastCursor'.
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLastCursorRequest()
    {
        $resourcePath = '/api/v2/nodes/last-cursor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getNode'.
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeRequest($node, $attributes = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling getNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getNodeAttributeSummary'.
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeAttributeSummaryRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getNodeAttributeSummary'
            );
        }

        $resourcePath = '/api/v2/users/{user}/node-attribute-summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{'.'user'.'}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getNodeEventLog'.
     *
     * @param string   $node       Node identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeEventLogRequest($node, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling getNodeEventLog'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/event-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getNodes'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param float    $deleted    Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodesRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $deleted = null)
    {
        $resourcePath = '/api/v2/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($deleted !== null) {
            $queryParams['deleted'] = ObjectSerializer::toQueryValue($deleted);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getParentNodes'.
     *
     * @param string   $node       Node identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     * @param bool     $self       Include requested collection itself at the end of the list (Will be ignored if the requested node is a file) (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getParentNodesRequest($node, $attributes = null, $self = null)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling getParentNodes'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/parents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($self !== null) {
            $queryParams['self'] = ObjectSerializer::toQueryValue($self);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getRootChildren'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     * @param bool     $recursive  Include children recursively. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRootChildrenRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null, $recursive = 'false')
    {
        $resourcePath = '/api/v2/collections/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($recursive !== null) {
            $queryParams['recursive'] = ObjectSerializer::toQueryValue($recursive);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getShare'.
     *
     * @param string $collection Collection identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getShareRequest($collection)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling getShare'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{'.'collection'.'}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getUser'.
     *
     * @param string   $user       Resource identifier (required)
     * @param string[] $attributes Filter attributes (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserRequest($user, $attributes = null)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{'.'user'.'}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getUserAvatar'.
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserAvatarRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getUserAvatar'
            );
        }

        $resourcePath = '/api/v2/users/{user}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{'.'user'.'}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['octet/stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['octet/stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getUserGroups'.
     *
     * @param string   $user       Resource identifier (required)
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserGroupsRequest($user, $query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling getUserGroups'
            );
        }

        $resourcePath = '/api/v2/users/{user}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{'.'user'.'}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getUsers'.
     *
     * @param string   $query      Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}). (optional)
     * @param string[] $attributes Filter attributes (optional)
     * @param float    $offset     Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset]. (optional)
     * @param float    $limit      Objects limit, per default 20 objects will get returned (optional)
     * @param string   $sort       Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}). (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUsersRequest($query = null, $attributes = null, $offset = null, $limit = null, $sort = null)
    {
        $resourcePath = '/api/v2/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if (is_array($attributes)) {
            $attributes = ObjectSerializer::serializeCollection($attributes, 'csv', true);
        }
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getV2'.
     *
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getV2Request()
    {
        $resourcePath = '/api/v2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'moveNode'.
     *
     * @param string $node     Node identifier (required)
     * @param string $destid   Destination collection, if this is null root is taken (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function moveNodeRequest($node, $destid = null, $conflict = '0')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling moveNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($destid !== null) {
            $queryParams['destid'] = ObjectSerializer::toQueryValue($destid);
        }
        // query params
        if ($conflict !== null) {
            $queryParams['conflict'] = ObjectSerializer::toQueryValue($conflict);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'patchGroup'.
     *
     * @param string                   $group Resource identifier (required)
     * @param \Balloon\Sdk\Model\Group $body  Set attributes for group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchGroupRequest($group, $body)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling patchGroup'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{'.'group'.'}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'patchUser'.
     *
     * @param string                  $user Resource identifier (required)
     * @param \Balloon\Sdk\Model\User $body Set attributes for user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchUserRequest($user, $body)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling patchUser'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{'.'user'.'}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'rollbackFile'.
     *
     * @param string $file File identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rollbackFileRequest($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling rollbackFile'
            );
        }

        $resourcePath = '/api/v2/files/{file}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($file !== null) {
            $resourcePath = str_replace(
                '{'.'file'.'}',
                ObjectSerializer::toPathValue($file),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'shareCollection'.
     *
     * @param string                   $collection Collection identifier (required)
     * @param \Balloon\Sdk\Model\Share $body       Create a new share from an existing collection (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shareCollectionRequest($collection, $body)
    {
        // verify the required parameter 'collection' is set
        if ($collection === null || (is_array($collection) && count($collection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collection when calling shareCollection'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling shareCollection'
            );
        }

        $resourcePath = '/api/v2/collections/{collection}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($collection !== null) {
            $resourcePath = str_replace(
                '{'.'collection'.'}',
                ObjectSerializer::toPathValue($collection),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'undeleteGroup'.
     *
     * @param string $group Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function undeleteGroupRequest($group)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling undeleteGroup'
            );
        }

        $resourcePath = '/api/v2/groups/{group}/undelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{'.'group'.'}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'undeleteNode'.
     *
     * @param string $node     Node identifier (required)
     * @param bool   $move     If node should also be moved during undelete (optional, default to false)
     * @param string $destid   If node should also be moved during undelete (optional)
     * @param float  $conflict Conflict resolution (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function undeleteNodeRequest($node, $move = 'false', $destid = null, $conflict = '0')
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling undeleteNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}/undelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($move !== null) {
            $queryParams['move'] = ObjectSerializer::toQueryValue($move);
        }
        // query params
        if ($destid !== null) {
            $queryParams['destid'] = ObjectSerializer::toQueryValue($destid);
        }
        // query params
        if ($conflict !== null) {
            $queryParams['conflict'] = ObjectSerializer::toQueryValue($conflict);
        }

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'undeleteUser'.
     *
     * @param string $user Resource identifier (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function undeleteUserRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling undeleteUser'
            );
        }

        $resourcePath = '/api/v2/users/{user}/undelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{'.'user'.'}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'updateNode'.
     *
     * @param string                  $node Node identifier (required)
     * @param \Balloon\Sdk\Model\Node $body Change attributes (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNodeRequest($node, $body)
    {
        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling updateNode'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{node}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{'.'node'.'}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PATCH',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'uploadChunk'.
     *
     * @param string $body File content (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadChunkRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadChunk'
            );
        }

        $resourcePath = '/api/v2/files/chunk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PUT',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'uploadFile'.
     *
     * @param string $body File content (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadFileRequest($body = null)
    {
        $resourcePath = '/api/v2/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);

        return new Request(
            'PUT',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option.
     *
     * @throws \RuntimeException on file opening failure
     *
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
